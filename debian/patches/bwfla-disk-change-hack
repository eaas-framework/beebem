Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 beebem (0.0.13-1bwfla1) trusty; urgency=medium
 .
   * added olges patch to change disks
Author: root <root@bw-fla.uni-freiburg.de>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ beebem-0.0.13/compile
@@ -0,0 +1,347 @@
+#! /bin/sh
+# Wrapper for compilers which do not understand '-c -o'.
+
+scriptversion=2012-10-14.11; # UTC
+
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Written by Tom Tromey <tromey@cygnus.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# This file is maintained in Automake, please report
+# bugs to <bug-automake@gnu.org> or send patches to
+# <automake-patches@gnu.org>.
+
+nl='
+'
+
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent tools from complaining about whitespace usage.
+IFS=" ""	$nl"
+
+file_conv=
+
+# func_file_conv build_file lazy
+# Convert a $build file to $host form and store it in $file
+# Currently only supports Windows hosts. If the determined conversion
+# type is listed in (the comma separated) LAZY, no conversion will
+# take place.
+func_file_conv ()
+{
+  file=$1
+  case $file in
+    / | /[!/]*) # absolute file, and not a UNC file
+      if test -z "$file_conv"; then
+	# lazily determine how to convert abs files
+	case `uname -s` in
+	  MINGW*)
+	    file_conv=mingw
+	    ;;
+	  CYGWIN*)
+	    file_conv=cygwin
+	    ;;
+	  *)
+	    file_conv=wine
+	    ;;
+	esac
+      fi
+      case $file_conv/,$2, in
+	*,$file_conv,*)
+	  ;;
+	mingw/*)
+	  file=`cmd //C echo "$file " | sed -e 's/"\(.*\) " *$/\1/'`
+	  ;;
+	cygwin/*)
+	  file=`cygpath -m "$file" || echo "$file"`
+	  ;;
+	wine/*)
+	  file=`winepath -w "$file" || echo "$file"`
+	  ;;
+      esac
+      ;;
+  esac
+}
+
+# func_cl_dashL linkdir
+# Make cl look for libraries in LINKDIR
+func_cl_dashL ()
+{
+  func_file_conv "$1"
+  if test -z "$lib_path"; then
+    lib_path=$file
+  else
+    lib_path="$lib_path;$file"
+  fi
+  linker_opts="$linker_opts -LIBPATH:$file"
+}
+
+# func_cl_dashl library
+# Do a library search-path lookup for cl
+func_cl_dashl ()
+{
+  lib=$1
+  found=no
+  save_IFS=$IFS
+  IFS=';'
+  for dir in $lib_path $LIB
+  do
+    IFS=$save_IFS
+    if $shared && test -f "$dir/$lib.dll.lib"; then
+      found=yes
+      lib=$dir/$lib.dll.lib
+      break
+    fi
+    if test -f "$dir/$lib.lib"; then
+      found=yes
+      lib=$dir/$lib.lib
+      break
+    fi
+    if test -f "$dir/lib$lib.a"; then
+      found=yes
+      lib=$dir/lib$lib.a
+      break
+    fi
+  done
+  IFS=$save_IFS
+
+  if test "$found" != yes; then
+    lib=$lib.lib
+  fi
+}
+
+# func_cl_wrapper cl arg...
+# Adjust compile command to suit cl
+func_cl_wrapper ()
+{
+  # Assume a capable shell
+  lib_path=
+  shared=:
+  linker_opts=
+  for arg
+  do
+    if test -n "$eat"; then
+      eat=
+    else
+      case $1 in
+	-o)
+	  # configure might choose to run compile as 'compile cc -o foo foo.c'.
+	  eat=1
+	  case $2 in
+	    *.o | *.[oO][bB][jJ])
+	      func_file_conv "$2"
+	      set x "$@" -Fo"$file"
+	      shift
+	      ;;
+	    *)
+	      func_file_conv "$2"
+	      set x "$@" -Fe"$file"
+	      shift
+	      ;;
+	  esac
+	  ;;
+	-I)
+	  eat=1
+	  func_file_conv "$2" mingw
+	  set x "$@" -I"$file"
+	  shift
+	  ;;
+	-I*)
+	  func_file_conv "${1#-I}" mingw
+	  set x "$@" -I"$file"
+	  shift
+	  ;;
+	-l)
+	  eat=1
+	  func_cl_dashl "$2"
+	  set x "$@" "$lib"
+	  shift
+	  ;;
+	-l*)
+	  func_cl_dashl "${1#-l}"
+	  set x "$@" "$lib"
+	  shift
+	  ;;
+	-L)
+	  eat=1
+	  func_cl_dashL "$2"
+	  ;;
+	-L*)
+	  func_cl_dashL "${1#-L}"
+	  ;;
+	-static)
+	  shared=false
+	  ;;
+	-Wl,*)
+	  arg=${1#-Wl,}
+	  save_ifs="$IFS"; IFS=','
+	  for flag in $arg; do
+	    IFS="$save_ifs"
+	    linker_opts="$linker_opts $flag"
+	  done
+	  IFS="$save_ifs"
+	  ;;
+	-Xlinker)
+	  eat=1
+	  linker_opts="$linker_opts $2"
+	  ;;
+	-*)
+	  set x "$@" "$1"
+	  shift
+	  ;;
+	*.cc | *.CC | *.cxx | *.CXX | *.[cC]++)
+	  func_file_conv "$1"
+	  set x "$@" -Tp"$file"
+	  shift
+	  ;;
+	*.c | *.cpp | *.CPP | *.lib | *.LIB | *.Lib | *.OBJ | *.obj | *.[oO])
+	  func_file_conv "$1" mingw
+	  set x "$@" "$file"
+	  shift
+	  ;;
+	*)
+	  set x "$@" "$1"
+	  shift
+	  ;;
+      esac
+    fi
+    shift
+  done
+  if test -n "$linker_opts"; then
+    linker_opts="-link$linker_opts"
+  fi
+  exec "$@" $linker_opts
+  exit 1
+}
+
+eat=
+
+case $1 in
+  '')
+     echo "$0: No command.  Try '$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: compile [--help] [--version] PROGRAM [ARGS]
+
+Wrapper for compilers which do not understand '-c -o'.
+Remove '-o dest.o' from ARGS, run PROGRAM with the remaining
+arguments, and rename the output as expected.
+
+If you are trying to build a whole package this is not the
+right script to run: please start by reading the file 'INSTALL'.
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "compile $scriptversion"
+    exit $?
+    ;;
+  cl | *[/\\]cl | cl.exe | *[/\\]cl.exe )
+    func_cl_wrapper "$@"      # Doesn't return...
+    ;;
+esac
+
+ofile=
+cfile=
+
+for arg
+do
+  if test -n "$eat"; then
+    eat=
+  else
+    case $1 in
+      -o)
+	# configure might choose to run compile as 'compile cc -o foo foo.c'.
+	# So we strip '-o arg' only if arg is an object.
+	eat=1
+	case $2 in
+	  *.o | *.obj)
+	    ofile=$2
+	    ;;
+	  *)
+	    set x "$@" -o "$2"
+	    shift
+	    ;;
+	esac
+	;;
+      *.c)
+	cfile=$1
+	set x "$@" "$1"
+	shift
+	;;
+      *)
+	set x "$@" "$1"
+	shift
+	;;
+    esac
+  fi
+  shift
+done
+
+if test -z "$ofile" || test -z "$cfile"; then
+  # If no '-o' option was seen then we might have been invoked from a
+  # pattern rule where we don't need one.  That is ok -- this is a
+  # normal compilation that the losing compiler can handle.  If no
+  # '.c' file was seen then we are probably linking.  That is also
+  # ok.
+  exec "$@"
+fi
+
+# Name of file we expect compiler to create.
+cofile=`echo "$cfile" | sed 's|^.*[\\/]||; s|^[a-zA-Z]:||; s/\.c$/.o/'`
+
+# Create the lock directory.
+# Note: use '[/\\:.-]' here to ensure that we don't use the same name
+# that we are using for the .o file.  Also, base the name on the expected
+# object file name, since that is what matters with a parallel build.
+lockdir=`echo "$cofile" | sed -e 's|[/\\:.-]|_|g'`.d
+while true; do
+  if mkdir "$lockdir" >/dev/null 2>&1; then
+    break
+  fi
+  sleep 1
+done
+# FIXME: race condition here if user kills between mkdir and trap.
+trap "rmdir '$lockdir'; exit 1" 1 2 15
+
+# Run the compile.
+"$@"
+ret=$?
+
+if test -f "$cofile"; then
+  test "$cofile" = "$ofile" || mv "$cofile" "$ofile"
+elif test -f "${cofile}bj"; then
+  test "${cofile}bj" = "$ofile" || mv "${cofile}bj" "$ofile"
+fi
+
+rmdir "$lockdir"
+exit $ret
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
--- beebem-0.0.13.orig/config.h.in
+++ beebem-0.0.13/config.h.in
@@ -51,6 +51,9 @@
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
--- beebem-0.0.13.orig/configure.in
+++ beebem-0.0.13/configure.in
@@ -17,7 +17,7 @@ AC_PROG_INSTALL
 
 
 # dnl Checks for GTK libraries.
-AM_PATH_GTK_2_0(2.2.0,,AC_MSG_ERROR(mypkgname 0.1 needs GTK+ 2.2.0))
+# AM_PATH_GTK_2_0(2.2.0,,AC_MSG_ERROR(mypkgname 0.1 needs GTK+ 2.2.0))
 
 
 
--- beebem-0.0.13.orig/src/Makefile.am
+++ beebem-0.0.13/src/Makefile.am
@@ -7,11 +7,11 @@ SUBDIRS = gui
 
 #INCLUDE = -I@top_srcdir@/src/gui
 
-#INCLUDES        = @GTK_CFLAGS@ -I@top_srcdir@/src/gui
-#LDADD           = @GTK_LIBS@ @top_srcdir@/src/gui/libeg.a
+#INCLUDES        = -I@top_srcdir@/src/gui
+#LDADD           = @top_srcdir@/src/gui/libeg.a
 
-INCLUDES        = @GTK_CFLAGS@ -I@top_srcdir@/src/gui -I@top_srcdir@/src/
-LDADD           = @GTK_LIBS@ @top_srcdir@/src/gui/libeg.a
+INCLUDES        = -I@top_srcdir@/src/gui -I@top_srcdir@/src/
+LDADD           =  @top_srcdir@/src/gui/libeg.a
 
 
 CXX = @CXX@ -Wall -DDATA_DIR=\"$(pkgdatadir)\" 
--- beebem-0.0.13.orig/src/beebem_pages.cpp
+++ beebem-0.0.13/src/beebem_pages.cpp
@@ -13,7 +13,7 @@
 
 #include "windows.h"
 
-#include <gtk/gtk.h>
+#include <stdint.h>
 
 // [TODO] This shouldn't really be here.
 #define SCREEN_WIDTH 640
@@ -345,11 +345,12 @@ static void ProcessGUIOption(EG_Widget *
 // TEMP FILE SELECTOR ======================================================
 
 static char *gtk_file_selector_filename_ptr;
-static GtkWidget *filew;
+//static GtkWidget *filew;
 int got_file;
 bool was_full_screen = false;
 
 /* Get the selected filename and print it to the console */
+/*
 static void file_ok_sel( GtkWidget        *w,
                          GtkFileSelection *fs )
 {
@@ -364,6 +365,7 @@ static void file_ok_sel( GtkWidget
 		EG_TickBox_Tick(gui.fullscreen_widget_ptr);
 	}
 }
+*/
 
 int Save_GTK_File_Selector(char *filename_ptr)
 {
@@ -381,6 +383,7 @@ int Save_GTK_File_Selector(char *filenam
 
 	got_file = false;
 
+	/*
 	gtk_init (&__argc, &__argv);
 
 	gtk_file_selector_filename_ptr = filename_ptr;
@@ -399,11 +402,43 @@ int Save_GTK_File_Selector(char *filenam
 
 	gtk_widget_show (filew);
 	gtk_main ();
-
+	*/
 	was_full_screen = false;
 	return(got_file);
 }
 
+
+#include <sys/types.h>
+#include <dirent.h>
+#include <errno.h>
+
+struct DiscSelectorContext
+{
+	bool exit_loop;
+
+	/* Don't free this pointer */
+	const char* selected_filename;
+};
+
+void DiscSelector_OnClose(EG_Widget* widget, void* data)
+{
+	struct DiscSelectorContext* context = (struct DiscSelectorContext*) data;
+	context->exit_loop = true;
+}
+
+void DiscSelector_OnAbort(EG_Widget* widget, void* data)
+{
+	struct DiscSelectorContext* context = (struct DiscSelectorContext*) data;
+	context->exit_loop = true;
+	context->selected_filename = NULL;
+}
+
+void DiscSelector_OnFileSelected(EG_Widget* widget, void* data)
+{
+	struct DiscSelectorContext* context = (struct DiscSelectorContext*) data;
+	context->selected_filename = EG_TickBox_GetCaption(widget);
+}
+
 int Open_GTK_File_Selector(char *filename_ptr)
 {
 
@@ -421,6 +456,166 @@ int Open_GTK_File_Selector(char *filenam
 
 	got_file = false;
 
+	const int padding_x = 10;
+	const int padding_y = 10;
+	const int line_height = 20;
+	const int char_width = 10;
+
+	const int max_filename_length = (SCREEN_WIDTH - 4 * padding_x) / char_width;
+	int longest_filename_length = 28;
+
+	const int max_num_files = 16;
+	char** files = new char*[max_num_files];
+	int num_files = 0;
+
+	// List all disc-files in current working dir
+	{
+		DIR* dir = opendir("./discs");
+		if (dir == NULL) {
+			pERROR("Failed to open ./discs directory! %s", strerror(errno));
+			return 0;
+		}
+
+		struct dirent* entry = NULL;
+		while ((entry = readdir(dir)) != NULL) {
+			if (num_files > max_num_files) {
+				pWARN("./discs directory contains more files, than currently can be displayed!");
+				break;
+			}
+
+			char* filename = entry->d_name;
+			const int filename_length = strlen(filename);
+			if (filename_length > max_filename_length) {
+				pWARN("File %s is too long to be displayed!", filename);
+				continue;
+			}
+
+			if (filename_length > longest_filename_length)
+				longest_filename_length = filename_length;
+
+			files[num_files] = strdup(filename);
+			++num_files;
+
+			pINFO("Found disc file: %s", filename);
+		}
+
+		closedir(dir);
+	}
+
+	SDL_Color color = MENU_COLORS;
+	EG_Widget* widget_ptr = NULL;
+	SDL_Rect widget_rect;
+
+	struct DiscSelectorContext context;
+	context.exit_loop = false;
+
+	const int window_w = char_width * longest_filename_length + (4 * padding_x);
+	const int window_h = (6 * padding_y) + (line_height * (num_files + 2));
+
+	SDL_Rect window_rect = CalcRectCentered(window_w, window_h);
+	EG_Window* window_ptr = EG_Window_Create("discsel:window", screen_ptr, color, window_rect);
+
+	/* Init widget's rectangle */
+	widget_rect.x = padding_x;
+	widget_rect.y = padding_y;
+	widget_rect.w = window_rect.w - (2 * padding_x);
+	widget_rect.h = line_height;
+
+	#define ADVANCE_LINE_RECT(_num_lines_) \
+		widget_rect.y += (_num_lines_) * line_height;
+
+	#define INDENT_LINE_RECT(_depth_) \
+		widget_rect.x += (_depth_) * padding_x; \
+		widget_rect.w -= (_depth_) * (padding_x + 2); \
+
+	/* Add title label */
+	widget_ptr = EG_Label_Create("discsel:title", color, EG_LABEL_ALIGN_CENTER, "Please, select a new disc:", widget_rect);
+	(void) EG_Window_AddWidget(window_ptr, widget_ptr);
+
+	/* Files widget + button group */
+
+	ADVANCE_LINE_RECT(1);
+	widget_rect.y += padding_y;
+	widget_rect.h = (num_files * line_height) + (2 * padding_y);
+
+	widget_ptr = EG_Box_Create("discsel:files_box", EG_BOX_BORDER_SUNK, color, widget_rect);
+	(void) EG_Window_AddWidget(window_ptr, widget_ptr);
+
+	INDENT_LINE_RECT(1);
+	widget_rect.y += padding_y;
+	widget_rect.h = line_height;
+
+	/* Add file entries */
+	EG_Widget* files_group_ptr = EG_RadioGroup_Create("discsel:files_group");
+	for (int i = 0; i < num_files; ++i) {
+		widget_ptr = EG_RadioButton_Create("discsel:file", color, files[i], widget_rect);
+		(void) EG_RadioGroup_AddButton(files_group_ptr, widget_ptr);
+		(void) EG_TickBox_SetMyCallback_OnClick(widget_ptr, DiscSelector_OnFileSelected, &context);
+		ADVANCE_LINE_RECT(1);
+
+		if (i == 0)
+			context.selected_filename = EG_TickBox_GetCaption(widget_ptr);
+	}
+
+	(void) EG_Window_AddWidget(window_ptr, files_group_ptr);
+
+	INDENT_LINE_RECT(-1);
+	widget_rect.y += 2 * padding_y;
+
+	const int button_w = 70;
+
+	/* Cancel button */
+	widget_rect.x = window_rect.w - padding_x - button_w;
+	widget_rect.w = button_w;
+	widget_ptr = EG_Button_Create("discsel:cancel", color, EG_BUTTON_ALIGN_CENTER, "Cancel", widget_rect);
+	(void) EG_Button_SetMyCallback_OnClick(widget_ptr, DiscSelector_OnAbort, &context);
+	(void) EG_Window_AddWidget(window_ptr, widget_ptr);
+
+	/* OK button */
+	widget_rect.x -= padding_x + button_w;
+	widget_ptr = EG_Button_Create("discsel:ok", color, EG_BUTTON_ALIGN_CENTER, "OK", widget_rect);
+	(void) EG_Button_SetMyCallback_OnClick(widget_ptr, DiscSelector_OnClose, &context);
+	(void) EG_Window_AddWidget(window_ptr, widget_ptr);
+
+	EG_Window_Show(window_ptr);
+
+	/* Run SDL's event loop here */
+	do {
+		SDL_Event event;
+		while (SDL_PollEvent(&event)){
+			switch (event.type) {
+				case SDL_QUIT:
+					DiscSelector_OnAbort(NULL, &context);
+					break;
+
+				case SDL_KEYDOWN:
+					if (event.key.keysym.sym == SDLK_ESCAPE)
+						DiscSelector_OnAbort(NULL, &context);
+					break;
+			}
+
+			EG_Window_ProcessEvent(window_ptr, &event, 0, 0);
+		}
+		EG_Window_ProcessEvent(window_ptr, NULL, 0,0);
+		SDL_Delay(25);
+	} while (!context.exit_loop);
+
+	if (context.selected_filename != NULL) {
+		strcpy(filename_ptr, context.selected_filename);
+		got_file = true;
+	}
+
+	/* Cleanup */
+	EG_Window_Hide(window_ptr);
+	EG_Window_DestroyAllChildWidgets(window_ptr);
+	EG_Window_Destroy(window_ptr);
+	for (int i = 0; i < num_files; ++i)
+		delete files[i];
+
+	#undef ADVANCE_LINE_RECT
+	#undef INDENT_LINE_RECT
+
+	/*
 	gtk_init (&__argc, &__argv);
 
 	gtk_file_selector_filename_ptr = filename_ptr;
@@ -439,11 +634,13 @@ int Open_GTK_File_Selector(char *filenam
   
 	gtk_widget_show (filew);
 	gtk_main ();
+	*/
 
 	was_full_screen = false;
 	return(got_file);
 }
 
+
 static void RunDisc(EG_Widget *widget_ptr, void *user_ptr)
 {
 	EG_Window *window_ptr = (EG_Window*) user_ptr;
@@ -1628,7 +1825,7 @@ static void Screen_Button_Back(EG_Widget
 
 static void Change_Windowed_Resolution(EG_Widget *widget_ptr, void *user_ptr)
 {
-	int value = (int) user_ptr;
+	intptr_t value = (intptr_t) user_ptr;
 	cfg_Windowed_Resolution = value;
 
 	EG_Window_Hide(gui.win_screen_ptr);
@@ -1650,7 +1847,7 @@ static void Change_Windowed_Resolution(E
 
 static void Change_Fullscreen_Resolution(EG_Widget *widget_ptr, void *user_ptr)
 {
-	int value = (int) user_ptr;
+	intptr_t value = (intptr_t) user_ptr;
 	cfg_Fullscreen_Resolution = value;
 
 	EG_Window_Hide(gui.win_screen_ptr);
--- beebem-0.0.13.orig/src/sdl.cpp
+++ beebem-0.0.13/src/sdl.cpp
@@ -571,6 +571,10 @@ int Create_Screen(void)
 
 //printf("2: flags set\n");
 
+	/* Make sure screen surface was free'd.
+	 */
+	if (screen_ptr != NULL) Destroy_Screen();
+
  //      if ( (screen_ptr=SDL_SetVideoMode(SDL_WINDOW_WIDTH, SDL_WINDOW_HEIGHT
         if ( (screen_ptr=SDL_SetVideoMode(width, height
 	 , 8, flags ) ) == NULL){
@@ -580,6 +584,10 @@ int Create_Screen(void)
                 return false;
         }
 
+	/* Update GUI pointers to screen surface.
+	 */
+	ClearWindowsBackgroundCacheAndResetSurface();
+
 //printf("3: SDL_SetVideoMode called\n");
 
 
@@ -1363,14 +1371,20 @@ static struct BeebKeyTrans SDLtoBeebEmKe
 
 {SDLK_PAUSE,		-2,-2},	// BREAK
 
+{SDLK_LEFTBRACKET,      3,8},   // "[" / "{" or left arrow and 1/4 (mode 7)
+{SDLK_RIGHTBRACKET,     5,8},   // "]" / "}" or right arrow and 3/4 (mode 7)
+
+{SDLK_BACKSLASH,        7,8},   // "\" / "|" or 1/4 and || (mode 7)
+
 //,   -3,-3,  // ******** PAGE UP
 //,   -3,-4,  // ******** PAGE DOWN
 //,   -4,0,   // ******** KEYPAD PLUS
 //,   -4,1,   // ******** KEYPAD MINUS
-//,	1,8,	// *** an up arrow and a maths divison symbol ???
-//,	3,8,	// *** a left facing arrow and a 1/4 percentage symbol ???
-//,	7,8,	// *** a 1/2 percentage symbol and two vertical lines ???
-//,	5,8,	// *** a right facing arrow and a 3/4 percentage symbol ???
+//              // The following key codes have different symbols in mode 7
+//,	1,8,	// *** an up arrow and a maths divison symbol or
+//,	3,8,	// *** a left facing arrow and a 1/4 percentage symbol or [/{
+//,	7,8,	// *** a 1/2 percentage symbol and two vertical lines or \/|
+//,	5,8,	// *** a right facing arrow and a 3/4 percentage symbol or ]/}
 
 {-1, -1, -1}              // ** END OF LIST **
 };
